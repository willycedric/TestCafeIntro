"use strict";
// -------------------------------------------------------------
// WARNING: this file is used by both the client and the server.
// Do not use any browser or node-specific API!
// -------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
exports.default = {
    [types_1.RUNTIME_ERRORS.cannotCreateMultipleLiveModeRunners]: 'Cannot create multiple live mode runners.',
    [types_1.RUNTIME_ERRORS.cannotRunLiveModeRunnerMultipleTimes]: 'Cannot run a live mode runner multiple times.',
    [types_1.RUNTIME_ERRORS.browserDisconnected]: 'The {userAgent} browser disconnected. This problem may appear when a browser hangs or is closed, or due to network issues.',
    [types_1.RUNTIME_ERRORS.cannotRunAgainstDisconnectedBrowsers]: 'The following browsers disconnected: {userAgents}. Tests will not be run.',
    [types_1.RUNTIME_ERRORS.cannotEstablishBrowserConnection]: 'Unable to establish one or more of the specified browser connections. This can be caused by network issues or remote device failure.',
    [types_1.RUNTIME_ERRORS.cannotFindBrowser]: 'Unable to find the browser. "{browser}" is not a browser alias or path to an executable file.',
    [types_1.RUNTIME_ERRORS.browserProviderNotFound]: 'The specified "{providerName}" browser provider was not found.',
    [types_1.RUNTIME_ERRORS.browserNotSet]: 'No browser selected to test against.',
    [types_1.RUNTIME_ERRORS.testSourcesNotSet]: 'No test file specified.',
    [types_1.RUNTIME_ERRORS.noTestsToRun]: 'No tests to run. Either the test files contain no tests or the filter function is too restrictive.',
    [types_1.RUNTIME_ERRORS.cannotFindReporterForAlias]: 'The provided "{name}" reporter does not exist. Check that you have specified the report format correctly.',
    [types_1.RUNTIME_ERRORS.multipleStdoutReporters]: 'Multiple reporters attempting to write to stdout: "{reporters}". Only one reporter can write to stdout.',
    [types_1.RUNTIME_ERRORS.optionValueIsNotValidRegExp]: 'The "{optionName}" option value is not a valid regular expression.',
    [types_1.RUNTIME_ERRORS.optionValueIsNotValidKeyValue]: 'The "{optionName}" option value is not a valid key-value pair.',
    [types_1.RUNTIME_ERRORS.invalidSpeedValue]: 'Speed should be a number between 0.01 and 1.',
    [types_1.RUNTIME_ERRORS.invalidConcurrencyFactor]: 'The concurrency factor should be an integer greater or equal to 1.',
    [types_1.RUNTIME_ERRORS.cannotDivideRemotesCountByConcurrency]: 'The number of remote browsers should be divisible by the factor of concurrency.',
    [types_1.RUNTIME_ERRORS.portsOptionRequiresTwoNumbers]: 'The "--ports" option requires two numbers to be specified.',
    [types_1.RUNTIME_ERRORS.portIsNotFree]: 'The specified {portNum} port is already in use by another program.',
    [types_1.RUNTIME_ERRORS.invalidHostname]: 'The specified "{hostname}" hostname cannot be resolved to the current machine.',
    [types_1.RUNTIME_ERRORS.cannotFindSpecifiedTestSource]: 'Cannot find a test source file at "{path}".',
    [types_1.RUNTIME_ERRORS.clientFunctionCodeIsNotAFunction]: '{#instantiationCallsiteName} code is expected to be specified as a function, but {type} was passed.',
    [types_1.RUNTIME_ERRORS.selectorInitializedWithWrongType]: '{#instantiationCallsiteName} is expected to be initialized with a function, CSS selector string, another Selector, node snapshot or a Promise returned by a Selector, but {type} was passed.',
    [types_1.RUNTIME_ERRORS.clientFunctionCannotResolveTestRun]: "{#instantiationCallsiteName} cannot implicitly resolve the test run in context of which it should be executed. If you need to call {#instantiationCallsiteName} from the Node.js API callback, pass the test controller manually via {#instantiationCallsiteName}'s `.with({ boundTestRun: t })` method first. Note that you cannot execute {#instantiationCallsiteName} outside the test code.",
    [types_1.RUNTIME_ERRORS.regeneratorInClientFunctionCode]: `{#instantiationCallsiteName} code, arguments or dependencies cannot contain generators or "async/await" syntax (use Promises instead).`,
    [types_1.RUNTIME_ERRORS.invalidClientFunctionTestRunBinding]: 'The "boundTestRun" option value is expected to be a test controller.',
    [types_1.RUNTIME_ERRORS.invalidValueType]: '{smthg} is expected to be a {type}, but it was {actual}.',
    [types_1.RUNTIME_ERRORS.unsupportedUrlProtocol]: 'The specified "{url}" test page URL uses an unsupported {protocol}:// protocol. Only relative URLs or absolute URLs with http://, https:// and file:// protocols are supported.',
    [types_1.RUNTIME_ERRORS.testControllerProxyCannotResolveTestRun]: `Cannot implicitly resolve the test run in the context of which the test controller action should be executed. Use test function's 't' argument instead.`,
    [types_1.RUNTIME_ERRORS.timeLimitedPromiseTimeoutExpired]: 'Timeout expired for a time limited promise',
    [types_1.RUNTIME_ERRORS.cannotUseScreenshotPathPatternWithoutBaseScreenshotPathSpecified]: 'Unable to set the screenshot path pattern when screenshots are disabled. Specify the base path where screenshots are stored to enable them.',
    [types_1.RUNTIME_ERRORS.cannotSetVideoOptionsWithoutBaseVideoPathSpecified]: 'Unable to set video or encoding options when video recording is disabled. Specify the base path where video files are stored to enable recording.',
    [types_1.RUNTIME_ERRORS.multipleAPIMethodCallForbidden]: 'You cannot call the "{methodName}" method more than once. Pass an array of parameters to this method instead.',
    [types_1.RUNTIME_ERRORS.invalidReporterOutput]: "Specify a file name or a writable stream as the reporter's output target.",
    [types_1.RUNTIME_ERRORS.cannotReadSSLCertFile]: 'Unable to read the "{path}" file, specified by the "{option}" ssl option. Error details:\n' +
        '\n' +
        '{err}',
    [types_1.RUNTIME_ERRORS.cannotPrepareTestsDueToError]: 'Cannot prepare tests due to an error.\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.cannotParseRawFile]: 'Cannot parse a test source file in the raw format at "{path}" due to an error.\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.testedAppFailedWithError]: 'Tested app failed with an error:\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.unableToOpenBrowser]: 'Was unable to open the browser "{alias}" due to error.\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.requestHookConfigureAPIError]: 'There was an error while configuring the request hook:\n' +
        '\n' +
        '{requestHookName}: {errMsg}',
    [types_1.RUNTIME_ERRORS.forbiddenCharatersInScreenshotPath]: 'There are forbidden characters in the "{screenshotPath}" {screenshotPathType}:\n' +
        ' {forbiddenCharsDescription}',
    [types_1.RUNTIME_ERRORS.cannotFindFFMPEG]: 'Unable to locate the FFmpeg executable required to record videos. Do one of the following:\n' +
        '\n' +
        '* add the FFmpeg installation directory to the PATH environment variable,\n' +
        '* specify the path to the FFmpeg executable in the FFMPEG_PATH environment variable or the ffmpegPath video option,\n' +
        '* install the @ffmpeg-installer/ffmpeg package from npm.',
    [types_1.RUNTIME_ERRORS.cannotFindTypescriptConfigurationFile]: 'Unable to find the TypeScript configuration file in "{filePath}"',
};
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVtcGxhdGVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Vycm9ycy9ydW50aW1lL3RlbXBsYXRlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSwrQ0FBK0M7QUFDL0MsZ0VBQWdFOztBQUVoRSxvQ0FBMEM7QUFFMUMsa0JBQWU7SUFDWCxDQUFDLHNCQUFjLENBQUMsbUNBQW1DLENBQUMsRUFBK0IsMkNBQTJDO0lBQzlILENBQUMsc0JBQWMsQ0FBQyxvQ0FBb0MsQ0FBQyxFQUE4QiwrQ0FBK0M7SUFDbEksQ0FBQyxzQkFBYyxDQUFDLG1CQUFtQixDQUFDLEVBQStDLDRIQUE0SDtJQUMvTSxDQUFDLHNCQUFjLENBQUMsb0NBQW9DLENBQUMsRUFBOEIsMkVBQTJFO0lBQzlKLENBQUMsc0JBQWMsQ0FBQyxnQ0FBZ0MsQ0FBQyxFQUFrQyxzSUFBc0k7SUFDek4sQ0FBQyxzQkFBYyxDQUFDLGlCQUFpQixDQUFDLEVBQWlELCtGQUErRjtJQUNsTCxDQUFDLHNCQUFjLENBQUMsdUJBQXVCLENBQUMsRUFBMkMsZ0VBQWdFO0lBQ25KLENBQUMsc0JBQWMsQ0FBQyxhQUFhLENBQUMsRUFBcUQsc0NBQXNDO0lBQ3pILENBQUMsc0JBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFpRCx5QkFBeUI7SUFDNUcsQ0FBQyxzQkFBYyxDQUFDLFlBQVksQ0FBQyxFQUFzRCxvR0FBb0c7SUFDdkwsQ0FBQyxzQkFBYyxDQUFDLDBCQUEwQixDQUFDLEVBQXdDLDJHQUEyRztJQUM5TCxDQUFDLHNCQUFjLENBQUMsdUJBQXVCLENBQUMsRUFBMkMseUdBQXlHO0lBQzVMLENBQUMsc0JBQWMsQ0FBQywyQkFBMkIsQ0FBQyxFQUF1QyxvRUFBb0U7SUFDdkosQ0FBQyxzQkFBYyxDQUFDLDZCQUE2QixDQUFDLEVBQXFDLGdFQUFnRTtJQUNuSixDQUFDLHNCQUFjLENBQUMsaUJBQWlCLENBQUMsRUFBaUQsOENBQThDO0lBQ2pJLENBQUMsc0JBQWMsQ0FBQyx3QkFBd0IsQ0FBQyxFQUEwQyxvRUFBb0U7SUFDdkosQ0FBQyxzQkFBYyxDQUFDLHFDQUFxQyxDQUFDLEVBQTZCLGlGQUFpRjtJQUNwSyxDQUFDLHNCQUFjLENBQUMsNkJBQTZCLENBQUMsRUFBcUMsNERBQTREO0lBQy9JLENBQUMsc0JBQWMsQ0FBQyxhQUFhLENBQUMsRUFBcUQsb0VBQW9FO0lBQ3ZKLENBQUMsc0JBQWMsQ0FBQyxlQUFlLENBQUMsRUFBbUQsZ0ZBQWdGO0lBQ25LLENBQUMsc0JBQWMsQ0FBQyw2QkFBNkIsQ0FBQyxFQUFxQyw2Q0FBNkM7SUFDaEksQ0FBQyxzQkFBYyxDQUFDLGdDQUFnQyxDQUFDLEVBQWtDLHFHQUFxRztJQUN4TCxDQUFDLHNCQUFjLENBQUMsZ0NBQWdDLENBQUMsRUFBa0MsOExBQThMO0lBQ2pSLENBQUMsc0JBQWMsQ0FBQyxrQ0FBa0MsQ0FBQyxFQUFnQyxpWUFBaVk7SUFDcGQsQ0FBQyxzQkFBYyxDQUFDLCtCQUErQixDQUFDLEVBQW1DLHdJQUF3STtJQUMzTixDQUFDLHNCQUFjLENBQUMsbUNBQW1DLENBQUMsRUFBK0Isc0VBQXNFO0lBQ3pKLENBQUMsc0JBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFrRCwwREFBMEQ7SUFDN0ksQ0FBQyxzQkFBYyxDQUFDLHNCQUFzQixDQUFDLEVBQTRDLGlMQUFpTDtJQUNwUSxDQUFDLHNCQUFjLENBQUMsdUNBQXVDLENBQUMsRUFBMkIseUpBQXlKO0lBQzVPLENBQUMsc0JBQWMsQ0FBQyxnQ0FBZ0MsQ0FBQyxFQUFrQyw0Q0FBNEM7SUFDL0gsQ0FBQyxzQkFBYyxDQUFDLGdFQUFnRSxDQUFDLEVBQUUsNklBQTZJO0lBQ2hPLENBQUMsc0JBQWMsQ0FBQyxrREFBa0QsQ0FBQyxFQUFnQixtSkFBbUo7SUFDdE8sQ0FBQyxzQkFBYyxDQUFDLDhCQUE4QixDQUFDLEVBQW9DLCtHQUErRztJQUNsTSxDQUFDLHNCQUFjLENBQUMscUJBQXFCLENBQUMsRUFBNkMsMkVBQTJFO0lBQzlKLENBQUMsc0JBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxFQUE2Qyw0RkFBNEY7UUFDNUYsSUFBSTtRQUNKLE9BQU87SUFFMUYsQ0FBQyxzQkFBYyxDQUFDLDRCQUE0QixDQUFDLEVBQUUseUNBQXlDO1FBQ3BDLElBQUk7UUFDSixjQUFjO0lBRWxFLENBQUMsc0JBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLGtGQUFrRjtRQUM3RSxJQUFJO1FBQ0osY0FBYztJQUV4RCxDQUFDLHNCQUFjLENBQUMsd0JBQXdCLENBQUMsRUFBRSxvQ0FBb0M7UUFDL0IsSUFBSTtRQUNKLGNBQWM7SUFFOUQsQ0FBQyxzQkFBYyxDQUFDLG1CQUFtQixDQUFDLEVBQUUsMERBQTBEO1FBQ3JELElBQUk7UUFDSixjQUFjO0lBRXpELENBQUMsc0JBQWMsQ0FBQyw0QkFBNEIsQ0FBQyxFQUFFLDBEQUEwRDtRQUNyRCxJQUFJO1FBQ0osNkJBQTZCO0lBRWpGLENBQUMsc0JBQWMsQ0FBQyxrQ0FBa0MsQ0FBQyxFQUFFLGtGQUFrRjtRQUM3RSw4QkFBOEI7SUFFeEYsQ0FBQyxzQkFBYyxDQUFDLGdCQUFnQixDQUFDLEVBQUUsOEZBQThGO1FBQ3pGLElBQUk7UUFDSiw2RUFBNkU7UUFDN0UsdUhBQXVIO1FBQ3ZILDBEQUEwRDtJQUVsRyxDQUFDLHNCQUFjLENBQUMscUNBQXFDLENBQUMsRUFBRSxrRUFBa0U7Q0FDN0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFdBUk5JTkc6IHRoaXMgZmlsZSBpcyB1c2VkIGJ5IGJvdGggdGhlIGNsaWVudCBhbmQgdGhlIHNlcnZlci5cbi8vIERvIG5vdCB1c2UgYW55IGJyb3dzZXIgb3Igbm9kZS1zcGVjaWZpYyBBUEkhXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmltcG9ydCB7IFJVTlRJTUVfRVJST1JTIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdENyZWF0ZU11bHRpcGxlTGl2ZU1vZGVSdW5uZXJzXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGNyZWF0ZSBtdWx0aXBsZSBsaXZlIG1vZGUgcnVubmVycy4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RSdW5MaXZlTW9kZVJ1bm5lck11bHRpcGxlVGltZXNdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBydW4gYSBsaXZlIG1vZGUgcnVubmVyIG11bHRpcGxlIHRpbWVzLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmJyb3dzZXJEaXNjb25uZWN0ZWRdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHt1c2VyQWdlbnR9IGJyb3dzZXIgZGlzY29ubmVjdGVkLiBUaGlzIHByb2JsZW0gbWF5IGFwcGVhciB3aGVuIGEgYnJvd3NlciBoYW5ncyBvciBpcyBjbG9zZWQsIG9yIGR1ZSB0byBuZXR3b3JrIGlzc3Vlcy4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RSdW5BZ2FpbnN0RGlzY29ubmVjdGVkQnJvd3NlcnNdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBmb2xsb3dpbmcgYnJvd3NlcnMgZGlzY29ubmVjdGVkOiB7dXNlckFnZW50c30uIFRlc3RzIHdpbGwgbm90IGJlIHJ1bi4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RFc3RhYmxpc2hCcm93c2VyQ29ubmVjdGlvbl06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VuYWJsZSB0byBlc3RhYmxpc2ggb25lIG9yIG1vcmUgb2YgdGhlIHNwZWNpZmllZCBicm93c2VyIGNvbm5lY3Rpb25zLiBUaGlzIGNhbiBiZSBjYXVzZWQgYnkgbmV0d29yayBpc3N1ZXMgb3IgcmVtb3RlIGRldmljZSBmYWlsdXJlLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRCcm93c2VyXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVW5hYmxlIHRvIGZpbmQgdGhlIGJyb3dzZXIuIFwie2Jyb3dzZXJ9XCIgaXMgbm90IGEgYnJvd3NlciBhbGlhcyBvciBwYXRoIHRvIGFuIGV4ZWN1dGFibGUgZmlsZS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5icm93c2VyUHJvdmlkZXJOb3RGb3VuZF06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBzcGVjaWZpZWQgXCJ7cHJvdmlkZXJOYW1lfVwiIGJyb3dzZXIgcHJvdmlkZXIgd2FzIG5vdCBmb3VuZC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5icm93c2VyTm90U2V0XTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ05vIGJyb3dzZXIgc2VsZWN0ZWQgdG8gdGVzdCBhZ2FpbnN0LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnRlc3RTb3VyY2VzTm90U2V0XTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTm8gdGVzdCBmaWxlIHNwZWNpZmllZC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5ub1Rlc3RzVG9SdW5dOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ05vIHRlc3RzIHRvIHJ1bi4gRWl0aGVyIHRoZSB0ZXN0IGZpbGVzIGNvbnRhaW4gbm8gdGVzdHMgb3IgdGhlIGZpbHRlciBmdW5jdGlvbiBpcyB0b28gcmVzdHJpY3RpdmUuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90RmluZFJlcG9ydGVyRm9yQWxpYXNdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgcHJvdmlkZWQgXCJ7bmFtZX1cIiByZXBvcnRlciBkb2VzIG5vdCBleGlzdC4gQ2hlY2sgdGhhdCB5b3UgaGF2ZSBzcGVjaWZpZWQgdGhlIHJlcG9ydCBmb3JtYXQgY29ycmVjdGx5LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLm11bHRpcGxlU3Rkb3V0UmVwb3J0ZXJzXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTXVsdGlwbGUgcmVwb3J0ZXJzIGF0dGVtcHRpbmcgdG8gd3JpdGUgdG8gc3Rkb3V0OiBcIntyZXBvcnRlcnN9XCIuIE9ubHkgb25lIHJlcG9ydGVyIGNhbiB3cml0ZSB0byBzdGRvdXQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMub3B0aW9uVmFsdWVJc05vdFZhbGlkUmVnRXhwXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgXCJ7b3B0aW9uTmFtZX1cIiBvcHRpb24gdmFsdWUgaXMgbm90IGEgdmFsaWQgcmVndWxhciBleHByZXNzaW9uLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLm9wdGlvblZhbHVlSXNOb3RWYWxpZEtleVZhbHVlXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIFwie29wdGlvbk5hbWV9XCIgb3B0aW9uIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGtleS12YWx1ZSBwYWlyLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmludmFsaWRTcGVlZFZhbHVlXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnU3BlZWQgc2hvdWxkIGJlIGEgbnVtYmVyIGJldHdlZW4gMC4wMSBhbmQgMS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkQ29uY3VycmVuY3lGYWN0b3JdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBjb25jdXJyZW5jeSBmYWN0b3Igc2hvdWxkIGJlIGFuIGludGVnZXIgZ3JlYXRlciBvciBlcXVhbCB0byAxLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdERpdmlkZVJlbW90ZXNDb3VudEJ5Q29uY3VycmVuY3ldOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIG51bWJlciBvZiByZW1vdGUgYnJvd3NlcnMgc2hvdWxkIGJlIGRpdmlzaWJsZSBieSB0aGUgZmFjdG9yIG9mIGNvbmN1cnJlbmN5LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnBvcnRzT3B0aW9uUmVxdWlyZXNUd29OdW1iZXJzXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIFwiLS1wb3J0c1wiIG9wdGlvbiByZXF1aXJlcyB0d28gbnVtYmVycyB0byBiZSBzcGVjaWZpZWQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMucG9ydElzTm90RnJlZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgc3BlY2lmaWVkIHtwb3J0TnVtfSBwb3J0IGlzIGFscmVhZHkgaW4gdXNlIGJ5IGFub3RoZXIgcHJvZ3JhbS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkSG9zdG5hbWVdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBzcGVjaWZpZWQgXCJ7aG9zdG5hbWV9XCIgaG9zdG5hbWUgY2Fubm90IGJlIHJlc29sdmVkIHRvIHRoZSBjdXJyZW50IG1hY2hpbmUuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90RmluZFNwZWNpZmllZFRlc3RTb3VyY2VdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDYW5ub3QgZmluZCBhIHRlc3Qgc291cmNlIGZpbGUgYXQgXCJ7cGF0aH1cIi4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jbGllbnRGdW5jdGlvbkNvZGVJc05vdEFGdW5jdGlvbl06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3sjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gY29kZSBpcyBleHBlY3RlZCB0byBiZSBzcGVjaWZpZWQgYXMgYSBmdW5jdGlvbiwgYnV0IHt0eXBlfSB3YXMgcGFzc2VkLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnNlbGVjdG9ySW5pdGlhbGl6ZWRXaXRoV3JvbmdUeXBlXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAneyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSBpcyBleHBlY3RlZCB0byBiZSBpbml0aWFsaXplZCB3aXRoIGEgZnVuY3Rpb24sIENTUyBzZWxlY3RvciBzdHJpbmcsIGFub3RoZXIgU2VsZWN0b3IsIG5vZGUgc25hcHNob3Qgb3IgYSBQcm9taXNlIHJldHVybmVkIGJ5IGEgU2VsZWN0b3IsIGJ1dCB7dHlwZX0gd2FzIHBhc3NlZC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jbGllbnRGdW5jdGlvbkNhbm5vdFJlc29sdmVUZXN0UnVuXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGNhbm5vdCBpbXBsaWNpdGx5IHJlc29sdmUgdGhlIHRlc3QgcnVuIGluIGNvbnRleHQgb2Ygd2hpY2ggaXQgc2hvdWxkIGJlIGV4ZWN1dGVkLiBJZiB5b3UgbmVlZCB0byBjYWxsIHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gZnJvbSB0aGUgTm9kZS5qcyBBUEkgY2FsbGJhY2ssIHBhc3MgdGhlIHRlc3QgY29udHJvbGxlciBtYW51YWxseSB2aWEgeyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSdzIGAud2l0aCh7IGJvdW5kVGVzdFJ1bjogdCB9KWAgbWV0aG9kIGZpcnN0LiBOb3RlIHRoYXQgeW91IGNhbm5vdCBleGVjdXRlIHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gb3V0c2lkZSB0aGUgdGVzdCBjb2RlLlwiLFxuICAgIFtSVU5USU1FX0VSUk9SUy5yZWdlbmVyYXRvckluQ2xpZW50RnVuY3Rpb25Db2RlXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gY29kZSwgYXJndW1lbnRzIG9yIGRlcGVuZGVuY2llcyBjYW5ub3QgY29udGFpbiBnZW5lcmF0b3JzIG9yIFwiYXN5bmMvYXdhaXRcIiBzeW50YXggKHVzZSBQcm9taXNlcyBpbnN0ZWFkKS5gLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkQ2xpZW50RnVuY3Rpb25UZXN0UnVuQmluZGluZ106ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBcImJvdW5kVGVzdFJ1blwiIG9wdGlvbiB2YWx1ZSBpcyBleHBlY3RlZCB0byBiZSBhIHRlc3QgY29udHJvbGxlci4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkVmFsdWVUeXBlXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tzbXRoZ30gaXMgZXhwZWN0ZWQgdG8gYmUgYSB7dHlwZX0sIGJ1dCBpdCB3YXMge2FjdHVhbH0uJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudW5zdXBwb3J0ZWRVcmxQcm90b2NvbF06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgc3BlY2lmaWVkIFwie3VybH1cIiB0ZXN0IHBhZ2UgVVJMIHVzZXMgYW4gdW5zdXBwb3J0ZWQge3Byb3RvY29sfTovLyBwcm90b2NvbC4gT25seSByZWxhdGl2ZSBVUkxzIG9yIGFic29sdXRlIFVSTHMgd2l0aCBodHRwOi8vLCBodHRwczovLyBhbmQgZmlsZTovLyBwcm90b2NvbHMgYXJlIHN1cHBvcnRlZC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy50ZXN0Q29udHJvbGxlclByb3h5Q2Fubm90UmVzb2x2ZVRlc3RSdW5dOiAgICAgICAgICAgICAgICAgICAgICAgICAgYENhbm5vdCBpbXBsaWNpdGx5IHJlc29sdmUgdGhlIHRlc3QgcnVuIGluIHRoZSBjb250ZXh0IG9mIHdoaWNoIHRoZSB0ZXN0IGNvbnRyb2xsZXIgYWN0aW9uIHNob3VsZCBiZSBleGVjdXRlZC4gVXNlIHRlc3QgZnVuY3Rpb24ncyAndCcgYXJndW1lbnQgaW5zdGVhZC5gLFxuICAgIFtSVU5USU1FX0VSUk9SUy50aW1lTGltaXRlZFByb21pc2VUaW1lb3V0RXhwaXJlZF06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RpbWVvdXQgZXhwaXJlZCBmb3IgYSB0aW1lIGxpbWl0ZWQgcHJvbWlzZScsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFVzZVNjcmVlbnNob3RQYXRoUGF0dGVybldpdGhvdXRCYXNlU2NyZWVuc2hvdFBhdGhTcGVjaWZpZWRdOiAnVW5hYmxlIHRvIHNldCB0aGUgc2NyZWVuc2hvdCBwYXRoIHBhdHRlcm4gd2hlbiBzY3JlZW5zaG90cyBhcmUgZGlzYWJsZWQuIFNwZWNpZnkgdGhlIGJhc2UgcGF0aCB3aGVyZSBzY3JlZW5zaG90cyBhcmUgc3RvcmVkIHRvIGVuYWJsZSB0aGVtLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFNldFZpZGVvT3B0aW9uc1dpdGhvdXRCYXNlVmlkZW9QYXRoU3BlY2lmaWVkXTogICAgICAgICAgICAgICAnVW5hYmxlIHRvIHNldCB2aWRlbyBvciBlbmNvZGluZyBvcHRpb25zIHdoZW4gdmlkZW8gcmVjb3JkaW5nIGlzIGRpc2FibGVkLiBTcGVjaWZ5IHRoZSBiYXNlIHBhdGggd2hlcmUgdmlkZW8gZmlsZXMgYXJlIHN0b3JlZCB0byBlbmFibGUgcmVjb3JkaW5nLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLm11bHRpcGxlQVBJTWV0aG9kQ2FsbEZvcmJpZGRlbl06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWW91IGNhbm5vdCBjYWxsIHRoZSBcInttZXRob2ROYW1lfVwiIG1ldGhvZCBtb3JlIHRoYW4gb25jZS4gUGFzcyBhbiBhcnJheSBvZiBwYXJhbWV0ZXJzIHRvIHRoaXMgbWV0aG9kIGluc3RlYWQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZFJlcG9ydGVyT3V0cHV0XTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU3BlY2lmeSBhIGZpbGUgbmFtZSBvciBhIHdyaXRhYmxlIHN0cmVhbSBhcyB0aGUgcmVwb3J0ZXIncyBvdXRwdXQgdGFyZ2V0LlwiLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RSZWFkU1NMQ2VydEZpbGVdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VuYWJsZSB0byByZWFkIHRoZSBcIntwYXRofVwiIGZpbGUsIHNwZWNpZmllZCBieSB0aGUgXCJ7b3B0aW9ufVwiIHNzbCBvcHRpb24uIEVycm9yIGRldGFpbHM6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vycn0nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFByZXBhcmVUZXN0c0R1ZVRvRXJyb3JdOiAnQ2Fubm90IHByZXBhcmUgdGVzdHMgZHVlIHRvIGFuIGVycm9yLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7ZXJyTWVzc2FnZX0nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFBhcnNlUmF3RmlsZV06ICdDYW5ub3QgcGFyc2UgYSB0ZXN0IHNvdXJjZSBmaWxlIGluIHRoZSByYXcgZm9ybWF0IGF0IFwie3BhdGh9XCIgZHVlIHRvIGFuIGVycm9yLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vyck1lc3NhZ2V9JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy50ZXN0ZWRBcHBGYWlsZWRXaXRoRXJyb3JdOiAnVGVzdGVkIGFwcCBmYWlsZWQgd2l0aCBhbiBlcnJvcjpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tlcnJNZXNzYWdlfScsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMudW5hYmxlVG9PcGVuQnJvd3Nlcl06ICdXYXMgdW5hYmxlIHRvIG9wZW4gdGhlIGJyb3dzZXIgXCJ7YWxpYXN9XCIgZHVlIHRvIGVycm9yLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7ZXJyTWVzc2FnZX0nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLnJlcXVlc3RIb29rQ29uZmlndXJlQVBJRXJyb3JdOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGNvbmZpZ3VyaW5nIHRoZSByZXF1ZXN0IGhvb2s6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tyZXF1ZXN0SG9va05hbWV9OiB7ZXJyTXNnfScsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMuZm9yYmlkZGVuQ2hhcmF0ZXJzSW5TY3JlZW5zaG90UGF0aF06ICdUaGVyZSBhcmUgZm9yYmlkZGVuIGNoYXJhY3RlcnMgaW4gdGhlIFwie3NjcmVlbnNob3RQYXRofVwiIHtzY3JlZW5zaG90UGF0aFR5cGV9OlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHtmb3JiaWRkZW5DaGFyc0Rlc2NyaXB0aW9ufScsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90RmluZEZGTVBFR106ICdVbmFibGUgdG8gbG9jYXRlIHRoZSBGRm1wZWcgZXhlY3V0YWJsZSByZXF1aXJlZCB0byByZWNvcmQgdmlkZW9zLiBEbyBvbmUgb2YgdGhlIGZvbGxvd2luZzpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKiBhZGQgdGhlIEZGbXBlZyBpbnN0YWxsYXRpb24gZGlyZWN0b3J5IHRvIHRoZSBQQVRIIGVudmlyb25tZW50IHZhcmlhYmxlLFxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKiBzcGVjaWZ5IHRoZSBwYXRoIHRvIHRoZSBGRm1wZWcgZXhlY3V0YWJsZSBpbiB0aGUgRkZNUEVHX1BBVEggZW52aXJvbm1lbnQgdmFyaWFibGUgb3IgdGhlIGZmbXBlZ1BhdGggdmlkZW8gb3B0aW9uLFxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKiBpbnN0YWxsIHRoZSBAZmZtcGVnLWluc3RhbGxlci9mZm1wZWcgcGFja2FnZSBmcm9tIG5wbS4nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRUeXBlc2NyaXB0Q29uZmlndXJhdGlvbkZpbGVdOiAnVW5hYmxlIHRvIGZpbmQgdGhlIFR5cGVTY3JpcHQgY29uZmlndXJhdGlvbiBmaWxlIGluIFwie2ZpbGVQYXRofVwiJyxcbn07XG4iXX0=